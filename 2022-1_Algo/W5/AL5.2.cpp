#include <iostream>
using namespace std;

#define INF 999

/*
input1
5 10
1 2 1
1 4 1
1 5 5
2 1 9
2 3 3
2 4 2
3 4 4
4 3 2
4 5 3
5 1 3
25
1 1
1 2
1 3
1 4
1 5
2 1
2 2
2 3
2 4
2 5
3 1
3 2
3 3
3 4
3 5
4 1
4 2
4 3
4 4
4 5
5 1
5 2
5 3
5 4
5 5
output
0 1 3 1 4
8 0 3 2 5
10 11 0 4 7
6 7 2 0 3
3 4 6 4 0
0 0 4 0 4
5 0 0 0 4
5 5 0 0 4
5 5 0 0 0
0 1 4 1 0
1 1
1 2
1 4 3
1 4
1 4 5
2 4 5 1
2 2
2 3
2 4
2 4 5
3 4 5 1
3 4 5 1 2
3 3
3 4
3 4 5
4 5 1
4 5 1 2
4 3
4 4
4 5
5 1
5 1 2
5 1 4 3
5 1 4
5 5

input2
5 8
1 2 7
1 3 4
1 4 6
1 5 1
3 2 2
3 4 5
4 2 3
5 4 1
25
1 1
1 2
1 3
1 4
1 5
2 1
2 2
2 3
2 4
2 5
3 1
3 2
3 3
3 4
3 5
4 1
4 2
4 3
4 4
4 5
5 1
5 2
5 3
5 4
5 5
output
0 5 4 2 1
999 0 999 999 999
999 2 0 5 999
999 3 999 0 999
999 4 999 1 0
0 5 0 5 0
0 0 0 0 0
0 0 0 0 0
0 0 0 0 0
0 4 0 0 0
1 1
1 5 4 2
1 3
1 5 4
1 5
NONE
2 2
NONE
NONE
NONE
NONE
3 2
3 3
3 4
NONE
NONE
4 2
NONE
4 4
NONE
NONE
5 4 2
NONE
5 4
5 5
*/

// directed graph에서 정점별 최단경로 구하는 문제 - floyd 이건 모든 정점에서 다른 정점으로 가는 최단 경로의 길이 모두 찾음

int W[INF][INF], // adjacency matrix - 그래프에서 가중치 저장 (길이 없으면 무한대 저장) - INPUT
                 // 근데 이 문제에서는 따로 W 배열 사용 안 하고 main에서 따로 다 입력받았음
                 // 이 문제에서는 W입력받아서 D^0 = W 로 안 하고 바로 D^0에 w 값 저장함
    D[INF][INF], // vi -> vj 로 가는 "최단 경로의 길이"를 저장하는 행렬 - OUTPUT
    // D^(k) : k개의 중간 정점을 지나는 최단 경로의 길이의 행렬
    // D^(k)[i][j] : vi ->vj 로 k개의 중간 정점을 지나는 최단 경로의 길이
    // D^0 : 다른 어떤 정점도 지나지 않는 최단 경로의 길이 (=W). 처음에 입력받는 가중치 (길 없으면 INF)
    P[INF][INF]; // vi ->vj 로 가는 최단 경로가 거쳐야 하는 정점 저장 - 경로 출력용
//중간에 놓여있는 정점 중 "가장 큰 인덱스" 저장, 정점이 없으면 0 저장 -> 처음에는 다 0으로 초기화
int stp[INF], endp[INF];

void init(int n)
{
    for (int i = 1; i <= n; i++)
    {
        for (int j = 1; j <= n; j++)
        {
            if (i == j)
                D[i][j] = 0;
            else
                D[i][j] = INF; // vi->vj 경로가 없으면 INF 표시
            P[i][j] = 0;
        }
    }
}

void floyd2(int n)
{
    for (int k = 1; k <= n; k++) // k = 1 -> D^1[i][j] 구하는 것 -> 계속 덮어써서 마지막에 k=n일 때는 최종적인 최단길이 저장됨
        for (int i = 1; i <= n; i++)
            for (int j = 1; j <= n; j++)
                // k 정점을 거쳐간 게 최단 경로면 (이전에 k-1개 정점 거친 경로보다 더 짧으면)
                if (D[i][j] > D[i][k] + D[k][j])
                {
                    P[i][j] = k;                 //경로 저장 (중간에 지나는 점 k 저장)
                    D[i][j] = D[i][k] + D[k][j]; //새로 업데이트 되는 최단 경로의 길이
                }
}

void path(int i, int j)
{
    int k = P[i][j];

    // P[i][j]==0 이면 출력 안 하고 함수 종료 -> 출발, 도착점을 출력 안 해주고
    // 중간에 거쳐가는 점만 출력해준다
    //경로 출력하려면 main에서 출발, 도착점 따로 출력해줘야함

    // P[i][j]==0 이라면 중간에 거쳐야 하는 지점이 없음
    // vi -> vj 로 다이렉트로 가는 게 최단 경로

    // k != 0  : 경유해가는 지점이 있는 최단경로
    if (k != 0)
    //어딘가를 거친 경로가 최단 경로라면 inorder 탐색
    { // vi -> vk -> vj 경로 출력하기
        // 1. (vi,vk) 의 최단 경로 출력
        // 그 사이에 더 다른 경로 존재할 수도 있으니까 여기서 또 찾아보기
        // 만약 vi -> vy -> vk 경로가 최단거리라면
        // vi -> vy 탐색해서 vi -> vy, 즉 path[i][y] =0 이라면
        // i에서 y로 가는 더 짧은 경로는 없는거니까 y 출력하고,,,,,
        path(i, k);
        // 2. vk 출력 후
        cout << k << " ";
        // 3. (vk,vj) 의 최단 경로 출력
        path(k, j);
    }
}

int main()
{
    int N, M, T, u, v, w;

    //입력1-첫 번째 줄에 정점의 개수 N과 간선의 개수 M이 주어진다.
    cin >> N; //정점 수
    cin >> M; //간선 수

    // 입력받기 전에 D,P 초기화
    // D 초기화 할 때 i==j이면 (자기 자신에서 자기자신에게 갈 때) 0, 아니면 나머지는 전부 INF 저장
    init(N);

    //입력2-두 번째 줄부터 M개의 간선의 정보가 주어진다.
    // u v w는 각각 간선의 출발 정점 u, 도착 정점 v, 해당 간선의 가중치 w로 주어진다.
    for (int i = 0; i < M; i++)
    {
        cin >> u >> v >> w;
        //이 과정에서 D^0 = W 저장
        // ppt에서는 이 부분을 floyd2 함수 내에서 첫 줄에서 했음
        if (D[u][v] > w) //자기 자신에 대한 경로 외에는 모두 INF 저장돼있으니까 w 저장하기
            D[u][v] = w; // directed graph
    }

    //입력3- 출발/도착 정점의 쌍의 개수 T가 주어진다.
    cin >> T;

    //입력4-T개의 출발/도착 정점의 쌍이 주어진다.
    for (int i = 0; i < T; i++)
        cin >> stp[i] >> endp[i];

    floyd2(N);

    //출력1-먼저, N * N 행렬 D를 출력한다
    for (int i = 1; i <= N; i++)
    {
        for (int j = 1; j <= N; j++)
        {
            if (j != N)
                cout << D[i][j] << " ";
            else
                cout << D[i][j];
        }

        cout << endl;
    }

    //출력2-다음에 N * N 행렬 P를 출력한다.
    for (int i = 1; i <= N; i++)
    {

        for (int j = 1; j <= N; j++)

            if (j != N)
                cout << P[i][j] << " ";
            else
                cout << P[i][j];

        cout << endl;
    }

    //출력3-D와 P 행렬의 출력 이후로 T 개의 최단 경로를 출력한다.
    for (int i = 0; i < T; i++)
    {
        //만약 출발 정점에서 도착 정점으로의 경로가 존재하지 않으면 NONE 이라고 출력한다.
        if (D[stp[i]][endp[i]] == INF)
        {
            cout << "NONE" << endl;
            continue;
        }
        //최단 경로는 출발 정점에서 시작하여 중간 정점을 모두 출력하고 도착 정점을 출력한다.
        cout << stp[i] << " ";
        path(stp[i], endp[i]);

        if (i != T - 1)
            cout << endp[i] << endl;
        else
            cout << endp[i];
    }
}