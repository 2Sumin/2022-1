#include <iostream>
#include <vector>
#include <queue>
using namespace std;
vector<int> dset; // 1ì°¨ì› ë°°ì—´ dset ì•ˆì— ê·¸ ì›ì†Œê°€ ì†í•´ìˆëŠ” ì§‘í•©ì„ ì €ì¥
// ì²˜ìŒì—ëŠ” ëª¨ë‘ ì„œë¡œì†Œ ì§‘í•©ì„ í˜•ì„±í•˜ë‹ˆê¹Œ dset[i]=i
// merge(1,10) í›„ì—ëŠ” 10ì´ 1ì´ ìˆëŠ” ì§‘í•© ì•ˆìœ¼ë¡œ ë“¤ì–´ê°€ë‹ˆê¹Œ
// dset[10]=1 -> find(1)=find(10)=1
// ex. dset[2]=10, dset[10]=4, dset[4]=4
// -> dset[i]=iì¼ ë•Œ iê°€ ë£¨íŠ¸ì¸ ì§‘í•©.
// 2,10,4ëŠ” ëª¨ë‘ ê°™ì€ ì§‘í•© ì•ˆì— ìˆë‹¤.

/*
input
5 7
1 2 1
1 3 3
2 3 7
2 4 6
3 4 4
3 5 2
4 5 5
output
1 2 1
3 5 2
1 3 3
3 4 4
*/

typedef struct edge
{
    //ì¶œë°œ, ë„ì°©, ê°€ì¤‘ì¹˜
    int u, v, w;
} edge_t;

struct edge_compare
{
    bool operator()(edge_t e1, edge_t e2)
    {
        if (e1.w > e2.w)
            return true;
        else
            return false;
    }
};
typedef vector<edge_t> set_of_edges;
typedef priority_queue<edge_t, vector<edge_t>, edge_compare> PriorityQueue;

void dset_init(int n)
{
    dset.resize(n + 1);
    for (int i = 1; i <= n; i++)
        dset[i] = i;
}

int dset_find(int i)
{
    while (dset[i] != i) // dset[i]==iì´ë©´ ë£¨íŠ¸ë‹ˆê¹Œ ë£¨íŠ¸ë¥¼ ì°¾ì„ ë•Œê¹Œì§€ ê³„ì† íƒ€ê³  ê°€ë³´ê¸°
        i = dset[i];
    return i;
}

void dset_merge(int p, int q)
{
    dset[p] = q;
    // pë¥¼ q ì§‘í•© ì•ˆìœ¼ë¡œ ë„£ìŒ
    // ë’¤ì— ìˆëŠ” ì›ì†Œë¥¼ ì• ì›ì†Œì˜ ì§‘í•©ìœ¼ë¡œ ì§‘ì–´ë„£ìŒ
}

void kruskal(int n, int m, set_of_edges &E, set_of_edges &F)
//             ì •ì  ìˆ˜, ê°„ì„  ìˆ˜, ê°„ì„  ì§‘í•©,         output
{
    int p, q;
    edge_t e;
    PriorityQueue PQ;

    // ê°„ì„ ì˜ ì§‘í•© Eë¥¼ weightì— ëŒ€í•œ ë¹„ë‚´ë¦¼ì°¨ìˆœ(ì˜¤ë¦„ì°¨ìˆœ)ìœ¼ë¡œ ì •ë ¬ í›„ ì‹œì‘
    // ì œì¼ ì•ì— ê°€ì¥ ì‘ì€ ì›ì†Œê°€ ì˜¤ê²Œ í•´ì„œ weightê°€ ì‘ì€ ê²ƒë¶€í„° MSTì— í¬í•¨í•˜ê¸° ìœ„í•¨
    // í”„ë¦¼ì—ì„œëŠ” weightë¥¼ 2ì°¨ì› ë°°ì—´ì— ë„£ì–´ì„œ ì‚¬ìš©í•˜ë‹ˆê¹Œ undirected ì¸ ê±¸ í‘œí˜„í•˜ê¸° ìœ„í•´ì„œ (x,y), (y,x) ë‘˜ ë‹¤ ì…ë ¥í•´ì¤˜ì•¼í–ˆì§€ë§Œ
    // í¬ë£¨ìŠ¤ì¹¼ì—ì„œëŠ” weightë¥¼ ë°°ì—´ë¡œ ì‚¬ìš©í•˜ëŠ” ê²Œ ì•„ë‹Œë°ë‹¤ weightìˆœìœ¼ë¡œ ì •ë ¬í•´ì•¼í•˜ë‹ˆê¹Œ ë‘˜ ë‹¤ ì…ë ¥í•  í•„ìš”ì—†ìŒ
    for (edge_t e : E)
        PQ.push(e);

    F.clear();    // ğ¹ = âˆ…;
    dset_init(n); //ì„œë¡œì†Œ ì§‘í•© nê°œë¡œ ì´ˆê¸°í™”

    while (F.size() < n - 1) // mstëŠ” edgeë¥¼ ë…¸ë“œìˆ˜-1ê°œë§Œí¼ ê°€ì§€ë‹ˆê¹Œ F.sizeê°€ n-1ì´ ëë‹¤ë©´ whileë¬¸ ë‹¤ì‹œ ëŒì§€ë§ê³  ëë‚´ê¸°
    {
        // 1. ì •ë ¬ëœ PQ(ì—¬ê¸°ì— ì €ì¥ëœ ê±´ ê°„ì„ !)ì—ì„œ ê°€ì¥ ìœ„ì— ìˆëŠ” ê°€ì¥ ì‘ì€ ì›ì†Œë¥¼ êº¼ë‚´ì˜¨ë‹¤.
        e = PQ.top();
        PQ.pop(); // edge with least weight not yet considered;

        //ë°©ê¸ˆ êº¼ë‚¸ eì˜ ë‘ ë…¸ë“œê°€ í˜„ì¬ ê°™ì€ ì§‘í•©ì— ì†í•´ìˆëŠ”ì§€ ë³´ê³  ì•„ë‹ˆë¼ë©´ ì—°ê²°í•´ì£¼ê¸°
        // findí•¨ìˆ˜ë¥¼ í†µí•´ì„œ ë§¤ê°œë³€ìˆ˜ì˜ ë£¨íŠ¸ë…¸ë“œê°€ ë¦¬í„´ë˜ë©´ í˜„ì¬ ë‘ ì›ì†Œê°€ ê°™ì€ ì§‘í•©ì— ì†í•´ìˆëŠ”ì§€ ê²€ì‚¬
        // (ë£¨íŠ¸ê°€ ê°™ìœ¼ë©´ ê°™ì€ ì§‘í•©ì— ì´ë¯¸ ìˆìŒ)
        // -> ê°™ì€ ê°’ì„ ê°€ì§€ë©´ ì´ë¯¸ conencted ëœ ê²ƒ-> í•œë²ˆ ë” ì—°ê²°í•˜ë©´ cycleì´ë‹ˆê¹Œ ê°–ë‹¤ë²„ë¦¬ê¸°

        // ì•„ë‹ˆë¼ë©´(ì„œë¡œ ë‹¤ë¥¸ ì§‘í•©ì´ë¼ë©´) Fì— eë¥¼ í¬í•¨í•˜ê¸°
        p = dset_find(e.u); // pê°€ e.uê°€ ì†í•œ ì§‘í•©ì„ ê°€ë¦¬í‚´
        q = dset_find(e.v);
        if (p != q)
        {
            dset_merge(p, q); // merge í•˜ë©´ ì›ë˜ q ì§‘í•©ì´ë‘ pì§‘í•©ì´ í•©ì³ì ¸ì„œ qê°€ p ì§‘í•© ì•ˆìœ¼ë¡œ ë“¤ì–´ê°
            // merge í›„ì—ëŠ” find(e.u), find(e.v)ì˜ ê²°ê³¼ê°€ pë¡œ ê°™ì•„ì§ (ê°™ì€ ì§‘í•©ì— ì†í•¨)
            // mergeí•œë‹¤ëŠ” ê±´ pì™€ q ë…¸ë“œë¥¼ ì´ì€ edgeë¥¼ MSTì— ì‚¬ìš©í•˜ê² ë‹¤!ë¼ëŠ” ë§ì´ë‹ˆê¹Œ Fì— ì¶”ê°€í•˜ê¸°
            F.push_back(e);
        }
    }
}

int main()
{
    // ì…ë ¥1 - ì²« ì¤„ì— ì •ì ì˜ ê°œìˆ˜ n, ê°„ì„ ì˜ ê°œìˆ˜ mì´ ì£¼ì–´ì§„ë‹¤.
    int n, m;
    cin >> n >> m;

    // ì…ë ¥2 - ë‘ ë²ˆì§¸ ì¤„ë¶€í„° (u,v,w) í˜•íƒœë¡œ m ê°œì˜ ê°„ì„ ì´ ì£¼ì–´ì§„ë‹¤.
    // uì™€ vëŠ” ì •ì ì˜ ë²ˆí˜¸ì´ê³ , 1ë¶€í„° nê¹Œì§€ì˜ ìì—°ìˆ˜ë¡œ í‘œì‹œí•œë‹¤.
    // wëŠ” ê°„ì„  <u, v>ì˜ ê°€ì¤‘ì¹˜ì´ë©°, ì–‘ì˜ ì •ìˆ˜ ê°’ìœ¼ë¡œ ì£¼ì–´ì§„ë‹¤.
    set_of_edges E, F;

    // í”„ë¦¼ì´ë‘ ë‹¤ë¥´ê²Œ ì—¬ê¸°ì„œëŠ” edgeë¥¼ ê¸°ì¤€ìœ¼ë¡œ ë´„
    edge_t input;
    for (int i = 1; i <= m; i++)
    {
        cin >> input.u >> input.v >> input.w;
        E.push_back(input);
    }

    kruskal(n, m, E, F);

    // ì¶œë ¥1 - í¬ë£¨ìŠ¤ì¹¼ ì•Œê³ ë¦¬ì¦˜ì˜ ì´ˆê¸° ë‹¨ê³„ë¶€í„° ì¢…ë£Œ ë‹¨ê³„ê¹Œì§€(n-1 times)
    // F ì§‘í•©ì— í¬í•¨ë˜ëŠ” ê°„ì„ ì„ ìˆœì„œëŒ€ë¡œ ì¶œë ¥í•œë‹¤. (u,v,w) í˜•íƒœë¡œ
    for (edge_t e : F)
    {
        cout << e.u << " " << e.v << " " << e.w << endl;
    }
}